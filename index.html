<!doctype html>
<html>
<head>
<style>
body, html {
    margin: 0;
    padding: 0;
}
</style>
<meta charset="UTF-8" />
<title>LD39: Herkuel the Strong Arm</title>
<script src="js/phaser.min.js"></script>
<script src="js/phaser-input.js"></script>
</head>
<body><script type="text/javascript">

window.onload = function() {

  // Because we need format strings
  String.prototype.format = function() {
      var formatted = this;
      for (var i = 0; i < arguments.length; i++) {
          var regexp = new RegExp('\\{'+i+'\\}', 'gi');
          formatted = formatted.replace(regexp, arguments[i]);
      }
      return formatted;
  };

  // This year theme is running out of power
  var game = new Phaser.Game(768,576, Phaser.AUTO, 'LD39: Herkuel the Strong Arm',
    { init: init, preload: preload, create: create, update: update, render:render }, false, false);

  var Objects = {};
  Objects.action = function(properties) {
    this.regex = properties["match"];
    this.texts = properties["texts"];
    this.title = properties["title"];
    this.currentTextIndex = 0;
  };

  Objects.action.prototype.match = function(m) {
    return m.match(this.regex);
  };

  Objects.action.prototype.printTextObj = function(textObj) {
    let text = this.texts[this.currentTextIndex++];
    this.currentTextIndex = this.currentTextIndex % this.texts.length;
    // Check if we need color replace
    const color_lookup = {
      0: "#FEFEFE", //Plain
      1: "#fee761" //Yellow
    }
    let replace = text.match(/(\$c\d+)/ig);
    textObj.colors = [];
    textObj.addColor("#FEFEFE", 0);
    if(replace) {
      for ( let i = 0; i < replace.length; i++) {
        const indx = text.indexOf(replace[i]);
        const color = color_lookup[/\d+/.exec(replace[i])];
        text = text.replace(replace[i], "");
        textObj.addColor(color, indx);
      }
    };
    textObj.text = text;
  };

  Objects.action.prototype.update = function(dt) {

  };

  // RETURNS gamedata
  Objects.getYarnDATA = function() {
    // Should really be AJAX'd but whatever let the page stall a bit while
    // it loads.
    let data;
    var xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.open('GET', 'assets/cards.json', false); // Replace 'my_data' with the path to your file
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            data = xobj.responseText;
          }
    };
    xobj.send(null);
    let YarnData = JSON.parse(data);
    // Re-map raw JSON to some useful obj.
    let obj = {}
    for(let i = 0; i < YarnData.length; i++) {
      obj[YarnData[i].title.toUpperCase()] = YarnData[i];
    };
    return obj;
  }

  Objects.parseData = function(obj, id) {
    id = id || "START";
    // Use hardcoded START key as the indicator of where to begin parsing.
    let actions = Objects.createActions(obj, obj[id], []);
    // Reverse actions so later actions get regex priority over older actions.
    return actions.reverse();
  };

  // Recursively create actions
  Objects.createActions = function (obj, action, actions, actionRegex=undefined) {
    const actionLinkIndex = (action.body.indexOf('->') != -1) ? action.body.indexOf('->') : action.body.length;
    const texts = action.body.substring(0,actionLinkIndex).split(/\n/).filter(
          function(n){ return (n != undefined) && (n != "") });
    const linkTexts = action.body.substring(actionLinkIndex).split(/\n?->\s?/).filter(
          function(n){ return (n != undefined) && (n != "") });
    if (actionRegex && texts.length != 0) {
        actions.push(new Objects.action({
          match: actionRegex,
          texts: texts,
          title: action.title,
        }));
    }
    for(let i = 0; i < linkTexts.length; i++) {
      const match = linkTexts[i].match(/(.*?)\s*(?:<<\s*(.*?)\s*>>)?\s*\[\[(.*)\]\]\s*$/);
      const regex = new RegExp(match[1], 'i');
      const nextCard = match[3].toUpperCase();
      // If we have a conditionals in our regex string.
      const conditional = match[2];
      if( conditional ) {

      } else {
         // Prevent recursion loops, see if we've already added
         if( actions.find(function(e) { return e.title == nextCard; }) == undefined) {
          actions.concat(Objects.createActions(obj, obj[nextCard], actions, regex));
         }
      }
    }
    return actions;
  };


  var input;
  var text;
  var eventText;
  var timeText;
  var timeLeft = 30.5;

  var actions = [];
  var defaultAction;
  var currentAction;

  var debugLogging = false;
  var DATA = Objects.getYarnDATA();

  function init() {
    game.renderer.renderSession.roundPixels = true;
    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
    game.scale.pageAlignHorizontally;
    game.scale.pageAlignVertically;
    //Phaser.Canvas.setImageRenderingCrisp(game.canvas);
    game.stage.smoothed = true;
    game.add.plugin(PhaserInput.Plugin);
  }

  function preload () {
    // This needs to be set to "anonymous" for it to work under CDNs
    game.load.crossOrigin = "Anonymous"
    // Assets here.
    game.load.image('bg', 'assets/test.png');
    // game.load.spritesheet('player-01', 'assets/ShooterThing.png', 137, 148);
  }

  function create () {
    game.stage.backgroundColor = '#000010';
    game.time.advancedTiming = true;
    game.time.desiredFps = 60;
    let bg = game.add.sprite(0, 0, 'bg');

    const style = { font: "18px Arial",
        fill: "#FEFEFE",
        boundsAlignH: "left",
        boundsAlignV: "top",
        wordWrap: true, wordWrapWidth: 650
    };
    const styleGrey = { font: "18px Arial", fill: "#8E8E8E" };

    input = game.add.inputField(0, 525, {
      font: '18px Arial',
      fill: '#FEFEFE',
      cursorColor : '#FEFEFE',
      fillAlpha: 0,
      fontWeight: 'bold',
      forceCase: PhaserInput.ForceCase.upper,
      borderRadius : 2,
      padding : 2,
      forceCase : "upper",
      width : 768,
      zoom: false
    });
    input.anchor.x = 0;
    input.anchor.y = 1;
    input.setText(">");

    text = game.add.text(20, 475, "I should do something", styleGrey);
    text.anchor.x = 0;
    text.anchor.y = 0.8;
    eventText = game.add.text(20, 475, "I'll need your help with this STRONGEST ARM compeitition! I don't have much time.", style);
    eventText.addColor('#fee761', eventText.text.indexOf("STRONGEST"));
    eventText.addColor('#FEFEFE', eventText.text.indexOf("compeitition"));
    eventText.setTextBounds(0, 0, 768, 56);

    let timerStyle = style;
    timerStyle.boundsAlignH = "right";
    timeText = game.add.text(0, 0, "Time: {0}".format(Math.round(timeLeft)), timerStyle);
    timeText.setTextBounds(0, 0, 768, 56);

    // Leave cursor on in input field when you hit enter.
    input.focusOutOnEnter = true;
    //start with focus on the element
    input.startFocus();
    actions = Objects.parseData(DATA);
    defaultAction = actions.splice(actions.findIndex(function(e) { return e.match("<<DEFAULT") }), 1)[0];
    currentAction = defaultAction;
  }

  function debugLog(log){
    if(debugLogging) {
      console.log(log);
    }
  }

  function getText() {
    return input.value.replace(/^>\s*/g, '');
  }

  function update () {
    const dt = game.time.elapsed/1000;
    if (input.focus) {
      // Wait till the user is done typing
    }
    else {
      let playerText = getText();
      const foundAction = actions.find(function(element) {
        return element.match(playerText);
      })
      if ( playerText == "" ) {
        // Do nothing
      } else if (foundAction) {
        currentAction = foundAction;
        // Do the aciton
        text.text = getText();
        currentAction.update(dt);
        currentAction.printTextObj(eventText);
      } else {
        currentAction = defaultAction;
        // Do the aciton
        text.text = getText();
        currentAction.update(dt);
        currentAction.printTextObj(eventText);
      }

      // Reset focus so the user can type
      input.setText(">");
      input.startFocus();
    }

    input.update();
    timeLeft -= dt;
    timeText.text = "Time: {0}".format(Math.round(timeLeft));
  }

  function render () {
    game.debug.text(game.time.fps || '--', 2, 14, "#00ff00");
  }
};
</script></body>
</html>
