<!doctype html>
<html>
<head>
<style>
body, html {
    margin: 0;
    padding: 0;
}
</style>
<meta charset="UTF-8" />
<title>LD39: Herkuel the Strong Arm</title>
<script src="js/phaser.min.js"></script>
<script src="js/phaser-input.js"></script>
</head>
<body><script type="text/javascript">

window.onload = function() {

  // Because we need format strings
  String.prototype.format = function() {
      var formatted = this;
      for (var i = 0; i < arguments.length; i++) {
          var regexp = new RegExp('\\{'+i+'\\}', 'gi');
          formatted = formatted.replace(regexp, arguments[i]);
      }
      return formatted;
  };

  // This year theme is running out of power
  var game = new Phaser.Game(768,576, Phaser.AUTO, 'LD39: Herkuel the Strong Arm',
    { init: init, preload: preload, create: create, update: update, render:render }, false, false);

  var Objects = {};
  Objects.action = function(properties) {
    this.regex = properties["match"];
    this.texts = properties["texts"];
    this.title = properties["title"];
    this.cond = properties["conditional"];
    this.parent = properties["parent"];
    this.currentTextIndex = 0;
    this.count = 0;
  };

  Objects.action.prototype.match = function(m) {
    if(this.cond != undefined) {
       return undefined;
    }
    return m.match(this.regex);
  };

  Objects.action.prototype.printTextObj = function(textObj, regexMatch) {
    this.count++;
    let text = this.texts[this.currentTextIndex++];
    this.currentTextIndex = this.currentTextIndex % this.texts.length;
    // Check if we need color replace
    const color_lookup = {
      0: "#FEFEFE", //Plain
      1: "#fee761" //Yellow
    }

    // Colors
    let replace = text.match(/(\$c\d+)/ig);
    textObj.colors = [];
    textObj.addColor("#FEFEFE", 0);
    if(replace) {
      for ( let i = 0; i < replace.length; i++) {
        const indx = text.indexOf(replace[i]);
        const color = color_lookup[/\d+/.exec(replace[i])];
        text = text.replace(replace[i], "");
        textObj.addColor(color, indx);
      }
    };
    // SUBSITUTIONS
    let sub = text.match(/\$sub/i);
    if (sub) {
      text = text.replace(sub[0], regexMatch[1]);
    }


    // Conditionals
    let cond = text.match(/(\s*<<\s*(.+)\s*>>\s*)$/i);
    if (cond) {
      eval(cond[2]);
      text = text.replace(cond[1], "");
    }

    textObj.text = text;
  };

  Objects.action.prototype.update = function(dt) {

  };

  // RETURNS gamedata
  Objects.getYarnDATA = function() {
    // Should really be AJAX'd but whatever let the page stall a bit while
    // it loads.
    let data;
    var xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.open('GET', 'assets/cards.json', false); // Replace 'my_data' with the path to your file
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            data = xobj.responseText;
          }
    };
    xobj.send(null);
    let YarnData = JSON.parse(data);
    // Re-map raw JSON to some useful obj.
    let obj = {}
    for(let i = 0; i < YarnData.length; i++) {
      obj[YarnData[i].title.toUpperCase()] = YarnData[i];
    };
    return obj;
  }

  Objects.parseData = function(obj, id, regex, exsting) {
    exsting = exsting || []
    id = id || "START";
    // Use hardcoded START key as the indicator of where to begin parsing.
    let actions = Objects.createActions(obj, obj[id.toUpperCase()], exsting, regex);
    // Reverse actions so later actions get regex priority over older actions.
    return actions.reverse();
  };

  // Recursively create actions
  Objects.createActions = function (obj, action, actions, actionRegex=undefined) {
    const actionLinkIndex = (action.body.indexOf('->') != -1) ? action.body.indexOf('->') : action.body.length;
    const texts = action.body.substring(0,actionLinkIndex).split(/\n/).filter(
          function(n){ return (n != undefined) && (n != "") });
    const linkTexts = action.body.substring(actionLinkIndex).split(/\n?->\s?/).filter(
          function(n){ return (n != undefined) && (n != "") });
    const actionName = action.title.toUpperCase();
    if (actionRegex && texts.length != 0) {
        actions.push(new Objects.action({
          match: actionRegex,
          texts: texts,
          title: actionName,
        }));
    }
    for(let i = 0; i < linkTexts.length; i++) {
      const match = linkTexts[i].match(/(.*?)\s*(?:<<\s*(.*?)\s*>>)?\s*\[\[(.*)\]\]\s*$/);
      const regex = new RegExp(match[1], 'i');
      const nextCard = match[3].toUpperCase();
      // If we have a conditionals in our regex string.
      const conditional = match[2];
      if( conditional ) {
        // Add action conditional stub, but don't add its children.
        actions.push(new Objects.action({
          title: nextCard,
          conditional: conditional,
          match: actionRegex,
          parent: actions.find(function(e) { return e.title == actionName; }),
        }));
      } else {
         // Prevent recursion loops, see if we've already added
         if( actions.find(function(e) { return e.title == nextCard; }) == undefined) {
          actions.concat(Objects.createActions(obj, obj[nextCard], actions, regex));
         }
      }
    }
    return actions;
  };


  var input;
  var text;
  var eventText;
  var timeText;

  var actions = [];
  var defaultAction;
  var currentAction;


  var timeLeft = 30.5;
  var isTrapped = false;
  var oneKnee = false;
  var isDistracted = false;
  var liftCount = 0;
  var isFocused = false;
  var isARGED = false;

  var debugLogging = false;
  var DATA = Objects.getYarnDATA();

  function ENDING (name) {
    if(name == "SHIT") {

    } else if ( name == "DIDNOTHING" ) {

    } else if ( name == "ZEN" ) {

    } else if ( name == "FLYAWAY" ) {

    } else if ( name == "MUTANT" ) {

    } else if ( name == "OOPS" ) {

    } else if ( name == "IHAVETHEPOWER" ) {

    } else if ( name == "STRONGESTARM" ) {

    }
  }

  function addCard(title,regex) {
    actions = Objects.parseData(DATA, title, regex, actions.reverse());
  }

  function giveTime(t) {
    timeLeft += t;
  }

  function removeCard(name) {
    const index = actions.findIndex(function(e) { return e.title == name });
    if ( index == -1 ) {
      return undefined;
    }
    return actions.splice(index,1);
  }

  function init() {
    game.renderer.renderSession.roundPixels = true;
    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
    game.scale.pageAlignHorizontally;
    game.scale.pageAlignVertically;
    //Phaser.Canvas.setImageRenderingCrisp(game.canvas);
    game.stage.smoothed = true;
    game.add.plugin(PhaserInput.Plugin);
  }

  function preload () {
    // This needs to be set to "anonymous" for it to work under CDNs
    game.load.crossOrigin = "Anonymous"
    // Assets here.
    game.load.image('bg', 'assets/test.png');
    // game.load.spritesheet('player-01', 'assets/ShooterThing.png', 137, 148);
  }

  function create () {
    game.stage.backgroundColor = '#000010';
    game.time.advancedTiming = true;
    game.time.desiredFps = 60;
    let bg = game.add.sprite(0, 0, 'bg');

    const style = { font: "18px Arial",
        fill: "#FEFEFE",
        boundsAlignH: "left",
        boundsAlignV: "top",
        wordWrap: true, wordWrapWidth: 650
    };
    const styleGrey = { font: "18px Arial", fill: "#8E8E8E" };

    input = game.add.inputField(0, 525, {
      font: '18px Arial',
      fill: '#FEFEFE',
      cursorColor : '#FEFEFE',
      fillAlpha: 0,
      fontWeight: 'bold',
      forceCase: PhaserInput.ForceCase.upper,
      borderRadius : 2,
      padding : 2,
      forceCase : "upper",
      width : 768,
      zoom: false
    });
    input.anchor.x = 0;
    input.anchor.y = 1;
    input.focusOutOnEnter = true;

    text = game.add.text(20, 475, "", styleGrey);
    text.anchor.x = 0;
    text.anchor.y = 0.8;
    eventText = game.add.text(20, 475, "", style);
    eventText.setTextBounds(0, 0, 768, 56);

    let timerStyle = style;
    timerStyle.boundsAlignH = "right";
    timeText = game.add.text(0, 0, "Time: {0}".format(Math.round(timeLeft)), timerStyle);
    timeText.setTextBounds(0, 0, 768, 56);

    // Leave cursor on in input field when you hit enter.
    restart();
  }

  function restart() {
    //start with focus on the element
    actions = Objects.parseData(DATA);
    input.startFocus();
    input.setText(">");
    isTrapped = false;
    oneKnee = false;
    isDistracted = false;
    isFocused = false;
    timeLeft = 30.5;
    defaultAction = removeCard("DEFAULT")[0];
    currentAction = defaultAction;
    text.text = "I should do something";
    eventText.text = "I'll need your help with this STRONGEST ARM compeitition! I don't have much time.";
    eventText.addColor('#fee761', eventText.text.indexOf("STRONGEST"));
    eventText.addColor('#FEFEFE', eventText.text.indexOf("compeitition"));
  }

  function debugLog(log){
    if(debugLogging) {
      console.log(log);
    }
  }

  function getText() {
    return input.value.replace(/^>\s*/g, '');
  }

  function update () {
    const dt = game.time.elapsed/1000;
    if (input.focus) {
      // Wait till the user is done typing
    }
    else {
      // In the game
      let playerText = getText();
      const foundAction = actions.find(function(element) {
        return element.match(playerText);
      })
      if ( playerText == "" ) {
        // Do nothing
      } else if (foundAction) {
        currentAction = foundAction;
        // Do the aciton
        text.text = getText();
        currentAction.update(dt);
        currentAction.printTextObj(eventText, foundAction.match(playerText));
      } else {
        currentAction = defaultAction;
        // Do the aciton
        text.text = getText();
        currentAction.update(dt);
        currentAction.printTextObj(eventText);
      }

      // Reset focus so the user can type
      input.setText(">");
      input.startFocus();
    }
    const conditionals = actions.filter(function(e){
      return e.cond != undefined;
    });
    for(let i=0; i < conditionals.length; i++) {
      let condAction = conditionals[i];
      if(eval(condAction.cond) == true) {
        console.log("MET CONDITION FOR: " + condAction.title);
        // Remove conditional action and add real aciton
        removeCard(condAction.title);
        addCard(condAction.title, condAction.regex)
      }
    }
    input.update();
    timeLeft -= dt;
    timeText.text = "Time: {0}".format(Math.round(timeLeft));
  }

  function render () {
    game.debug.text(game.time.fps || '--', 2, 14, "#00ff00");
  }
};
</script></body>
</html>
