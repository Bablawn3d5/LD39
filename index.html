<!doctype html>
<html>
<head>
<style>
body, html {
    margin: 0;
    padding: 0;
}
</style>
<meta charset="UTF-8" />
<title>LD39: Herkuel the Strong Arm</title>
<script src="js/phaser.min.js"></script>
<script src="js/phaser-input.js"></script>
</head>
<body><script type="text/javascript">

window.onload = function() {

  // Because we need format strings
  String.prototype.format = function() {
      var formatted = this;
      for (var i = 0; i < arguments.length; i++) {
          var regexp = new RegExp('\\{'+i+'\\}', 'gi');
          formatted = formatted.replace(regexp, arguments[i]);
      }
      return formatted;
  };

  // This year theme is running out of power
  var game = new Phaser.Game(768,576, Phaser.AUTO, 'LD39: Herkuel the Strong Arm',
    { init: init, preload: preload, create: create, update: update, render:render }, false, false);

  var Objects = {};
  Objects.action = function(properties) {
    this.regex = properties["match"];
    this.texts = properties["texts"];
    this.title = properties["title"];
    this.cond = properties["conditional"];
    this.parent = properties["parent"];
    this.currentTextIndex = 0;
    this.count = 0;
  };

  Objects.action.prototype.match = function(m) {
    if(this.cond != undefined) {
       return undefined;
    }
    return m.match(this.regex);
  };

  Objects.action.prototype.printTextObj = function(textObj, regexMatch) {
    this.count++;
    let text = this.texts[this.currentTextIndex++];
    this.currentTextIndex = this.currentTextIndex % this.texts.length;
    // Check if we need color replace
    const color_lookup = {
      0: "#FEFEFE", //Plain
      1: "#fee761" //Yellow
    }

    // Colors
    let replace = text.match(/(\$c\d+)/ig);
    textObj.colors = [];
    textObj.addColor("#FEFEFE", 0);
    if(replace) {
      for ( let i = 0; i < replace.length; i++) {
        const indx = text.indexOf(replace[i]);
        const color = color_lookup[/\d+/.exec(replace[i])];
        text = text.replace(replace[i], "");
        textObj.addColor(color, indx);
      }
    };
    // SUBSITUTIONS
    let sub = text.match(/\$sub/i);
    if (sub) {
      text = text.replace(sub[0], regexMatch[1]);
    }


    // Conditionals
    let cond = text.match(/(\s*<<\s*(.+)\s*>>\s*)$/i);
    if (cond) {
      eval(cond[2]);
      text = text.replace(cond[1], "");
    }

    textObj.text = text;
  };

  Objects.action.prototype.update = function(dt) {

  };

  // RETURNS gamedata
  Objects.getYarnDATA = function() {
    // Should really be AJAX'd but whatever let the page stall a bit while
    // it loads.
    let data;
    var xobj = new XMLHttpRequest();
    xobj.overrideMimeType("application/json");
    xobj.open('GET', 'assets/cards.json', false); // Replace 'my_data' with the path to your file
    xobj.onreadystatechange = function () {
          if (xobj.readyState == 4 && xobj.status == "200") {
            // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
            data = xobj.responseText;
          }
    };
    xobj.send(null);
    let YarnData = JSON.parse(data);
    // Re-map raw JSON to some useful obj.
    let obj = {}
    for(let i = 0; i < YarnData.length; i++) {
      obj[YarnData[i].title.toUpperCase()] = YarnData[i];
    };
    return obj;
  }

  Objects.parseData = function(obj, id, regex, exsting) {
    exsting = exsting || []
    id = id || "START";
    // Use hardcoded START key as the indicator of where to begin parsing.
    let actions = Objects.createActions(obj, obj[id.toUpperCase()], exsting, regex);
    // Reverse actions so later actions get regex priority over older actions.
    return actions.reverse();
  };

  // Recursively create actions
  Objects.createActions = function (obj, action, actions, actionRegex=undefined) {
    const actionLinkIndex = (action.body.indexOf('->') != -1) ? action.body.indexOf('->') : action.body.length;
    const texts = action.body.substring(0,actionLinkIndex).split(/\n/).filter(
          function(n){ return (n != undefined) && (n != "") });
    const linkTexts = action.body.substring(actionLinkIndex).split(/\n?->\s?/).filter(
          function(n){ return (n != undefined) && (n != "") });
    const actionName = action.title.toUpperCase();
    if (actionRegex && texts.length != 0) {
        actions.push(new Objects.action({
          match: actionRegex,
          texts: texts,
          title: actionName,
        }));
    }
    for(let i = 0; i < linkTexts.length; i++) {
      const match = linkTexts[i].match(/(.*?)\s*(?:<<\s*(.*?)\s*>>)?\s*\[\[(.*)\]\]\s*$/);
      const regex = new RegExp(match[1], 'i');
      const nextCard = match[3].toUpperCase();
      // If we have a conditionals in our regex string.
      const conditional = match[2];
      if( conditional ) {
        // Add action conditional stub, but don't add its children.
        actions.push(new Objects.action({
          title: nextCard,
          conditional: conditional,
          match: actionRegex,
          parent: actions.find(function(e) { return e.title == actionName; }),
        }));
      } else {
         // Prevent recursion loops, see if we've already added
         if( actions.find(function(e) { return e.title == nextCard; }) == undefined) {
          actions.concat(Objects.createActions(obj, obj[nextCard], actions, regex));
         }
      }
    }
    return actions;
  };


  var input;
  var text;
  var eventText;
  var timeText;

  var actions = [];
  var titleScreen;
  var acheivos = {};
  var defaultAction;
  var currentAction;


  var timeLeft = 45;
  var isTrapped;
  var oneKnee;
  var isDistracted;
  var isFocused;
  var isARGED;
  var inGame = false;

  var debugLogging = false;
  var DATA = Objects.getYarnDATA();

  function ENDING (name) {
    text.text = "Type START to begin a new game";
    titleScreen.visible = true;
    inGame = false;
    if(name == "SHIT") {
      acheivos[1].got = true;
    } else if ( name == "DIDNOTHING" ) {
      textObj.text = "Oops, I couldn't hold that bar up any longer.";
    } else if ( name == "ZEN" ) {
      acheivos[2].got = true;

    } else if ( name == "FLYAWAY" ) {
      acheivos[3].got = true;

    } else if ( name == "MUTANT" ) {
      acheivos[6].got = true;

    } else if ( name == "OOPS" ) {

    } else if ( name == "IHAVETHEPOWER" ) {
      acheivos[5].got = true;

    } else if ( name == "STRONGESTARM" ) {
      acheivos[4].got = true;

    }
    Object.keys(acheivos).forEach(function (key) {
      if(!acheivos[key].got) {
        acheivos[key].s.visible = true;
      }
      acheivos[key].text.visible = true;
    });
  }

  function addCard(title,regex) {
    actions = Objects.parseData(DATA, title, regex, actions.reverse());
  }

  function giveTime(t) {
    timeLeft += t;
  }

  function removeCard(name) {
    const index = actions.findIndex(function(e) { return e.title == name });
    if ( index == -1 ) {
      return undefined;
    }
    return actions.splice(index,1);
  }

  function init() {
    game.renderer.renderSession.roundPixels = true;
    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
    game.scale.pageAlignHorizontally;
    game.scale.pageAlignVertically;
    //Phaser.Canvas.setImageRenderingCrisp(game.canvas);
    game.stage.smoothed = true;
    game.add.plugin(PhaserInput.Plugin);
  }

  function preload () {
    // This needs to be set to "anonymous" for it to work under CDNs
    game.load.crossOrigin = "Anonymous"
    // Assets here.
    game.load.image('bg', 'assets/test.png');
    game.load.image('title', 'assets/title2.png');
    game.load.image('invis', 'assets/invis.png');
    game.load.spritesheet('icons', 'assets/overlay.png', 76, 72);
  }

  function create () {
    game.stage.backgroundColor = '#000010';
    game.time.advancedTiming = true;
    game.time.desiredFps = 60;
    let bg = game.add.sprite(0, 0, 'bg');
    titleScreen = game.add.sprite(0, 0, 'title');


    const style = { font: "18px Arial",
        fill: "#FEFEFE",
        boundsAlignH: "left",
        boundsAlignV: "top",
        wordWrap: true, wordWrapWidth: 650
    };
    const styleGrey = { font: "18px Arial", fill: "#8E8E8E" };
    const styleAcheivo = { font: "14px Arial",
        fill: "#FEFEFE",
        boundsAlignH: "left",
        boundsAlignV: "top",
        wordWrap: true, wordWrapWidth: 650};

    {
        let icon = game.add.sprite(8*4, 35*4, 'icons');
        icon.animations.add('1', [0], 0, false);
        icon.animations.play('1');
        let a_text = game.add.text(30*4, 36*4,
          "THATS SHITTY\nThat's an embarassing way \nto end it eh?",
          styleAcheivo);
        acheivos[1] = { s: icon, got: false, text: a_text};
    }
    {
        let icon = game.add.sprite(8*4, 56*4, 'icons');
        icon.animations.add('2', [1], 0, false);
        icon.animations.play('2');
        let a_text = game.add.text(30*4, 57*4,
          "PERFECT HARMONY\nDeep thoughts and even \ndeeper balance.",
          styleAcheivo);
        acheivos[2] = { s: icon, got: false, text: a_text };
    }
    {
        let icon = game.add.sprite(8*4, 78*4, 'icons');
        icon.animations.add('3', [2], 0, false);
        icon.animations.play('3');
        let a_text = game.add.text(30*4, 79*4,
          "FLEW AWAY\nThese wings will carry you anywhere \nbe free my friend",
          styleAcheivo);
        acheivos[3] = { s: icon, got: false, text: a_text };
    }
    {
        let icon = game.add.sprite(98*4, 78*4, 'icons');
        icon.animations.add('4', [3], 0, false);
        icon.animations.play('4');
        let a_text = game.add.text(118*4, 79*4,
          "STRONGEST ARM CHAMPION\nA true champion",
          styleAcheivo);
        acheivos[4] = { s: icon, got: false, text: a_text };
    }
    {
        let icon = game.add.sprite(98*4, 56*4, 'icons');
        icon.animations.add('5', [4], 0, false);
        icon.animations.play('5');
        let a_text = game.add.text(118*4, 57*4,
          "KINDA FORGOT\nOoops, kidna got carried away\n there.",
          styleAcheivo);
        acheivos[5] = { s: icon, got: false, text: a_text };
    }
    {
        let icon = game.add.sprite(97*4, 35*4, 'icons');
        icon.animations.add('6', [5], 0, false);
        icon.animations.play('6');
        let a_text = game.add.text(118*4, 36*4,
          "HOW DID THAT HAPPEN\nI did say I can do anything right?",
          styleAcheivo);
        acheivos[6] = { s: icon, got: false, text: a_text };
    }

    {
        let button = game.add.button(40*4, 98*4, 'invis', function() {
        // open in the same window (like clicking a link)
        window.location.href = "https://phen.itch.io"}, this);
        let a_text = game.add.text(26*4, 98*4,
          "A game by http://phen.itch.io",
          styleAcheivo);
        a_text.addColor('#2fefFF', a_text.text.indexOf("http://"));

        button.width = 120;
        button.height = 30;
        acheivos[7] = { s: button, got: false, text: a_text };
    }


    {
        let button = game.add.button(140*4, 98*4, 'invis', function() {
        // open in the same window (like clicking a link)
        window.location.href = "https://Twitter.com/tehPHEN"}, this);
        let a_text = game.add.text(126*4, 98*4,
          "Twitter: @tehPHEN",
          styleAcheivo);
        a_text.addColor('#2fefFF', a_text.text.indexOf("@tehPHEN"));

        button.width = 80;
        button.height = 30;
        acheivos[7] = { s: button, got: false, text: a_text };
    }


    // {
    //     let button = game.add.button(26*4, 98*4, 'icons', function() {
    //     // open in the same window (like clicking a link)
    //     window.location.href = "https://phen.itch.io"}, this);
    //     let a_text = game.add.text(26*4, 98*4,
    //       "A game by http://phen.itch.io! ",
    //       styleAcheivo);
    //     acheivos[7] = { s: button, got: false, text: a_text };
    // }

    input = game.add.inputField(0, 525, {
      font: '18px Arial',
      fill: '#FEFEFE',
      cursorColor : '#FEFEFE',
      fillAlpha: 0,
      fontWeight: 'bold',
      forceCase: PhaserInput.ForceCase.upper,
      borderRadius : 2,
      padding : 2,
      forceCase : "upper",
      width : 768,
      zoom: false
    });
    input.anchor.x = 0;
    input.anchor.y = 1;
    input.focusOutOnEnter = true;

    text = game.add.text(20, 475, "", styleGrey);
    text.anchor.x = 0;
    text.anchor.y = 0.8;
    eventText = game.add.text(20, 475, "", style);
    eventText.setTextBounds(0, 0, 768, 56);

    let timerStyle = style;
    timerStyle.boundsAlignH = "right";
    timeText = game.add.text(0, 0, "Time: {0}".format(Math.round(timeLeft)), timerStyle);
    timeText.setTextBounds(0, 0, 768, 56);

    // Leave cursor on in input field when you hit enter.
    //restart();
    text.text = "Type START to begin a new game";
    eventText.text = "I need to proove myself in this STRONGEST ARM compeitition!";
    eventText.addColor('#fee761', eventText.text.indexOf("STRONGEST"));
    eventText.addColor('#FEFEFE', eventText.text.indexOf("compeitition"));
  }

  function restart() {
    //start with focus on the element
    actions = Objects.parseData(DATA);
    input.startFocus();
    input.setText(">");
    inGame = true;
    isTrapped = false;
    oneKnee = false;
    isDistracted = false;
    isFocused = false;
    timeLeft = 45.5;
    defaultAction = removeCard("DEFAULT")[0];
    currentAction = defaultAction;
    text.text = "I should do something";
    eventText.text = "I need your HELP. What should I do? I don't have much TIME";
    eventText.addColor('#fee761', eventText.text.indexOf("help"));
    eventText.addColor('#FEFEFE', eventText.text.indexOf(". What"));
    eventText.addColor('#fee761', eventText.text.indexOf("TIME"));
    // Hide achiveo covers
    Object.keys(acheivos).forEach(function (key) {
      acheivos[key].s.visible = false;
      acheivos[key].text.visible = false;
    });
    titleScreen.visible = false;
  }

  function debugLog(log){
    if(debugLogging) {
      console.log(log);
    }
  }

  function getText() {
    return input.value.replace(/^>\s*/g, '');
  }

  function update () {
    const dt = game.time.elapsed/1000;
    input.update();
    if( inGame ) {
      timeLeft -= dt;
      timeText.text = "Time: {0}".format(Math.round(timeLeft));
      if(timeLeft < 0) {
        ENDING('DIDNOTHING')
      }
    }

    if (input.focus) {
      // Wait till the user is done typing
    } else if (!inGame) {
      let playerText = getText();
      if ( playerText == "START" ) {
        restart();
      }

      // Reset focus so the user can type
      input.setText(">");
      input.startFocus();
    }
    else {
      // In the game
      let playerText = getText();
      const foundAction = actions.find(function(element) {
        return element.match(playerText);
      })
      if ( playerText == "" ) {
        // Do nothing
      } else if (foundAction) {
        currentAction = foundAction;
        // Do the aciton
        text.text = getText();
        currentAction.update(dt);
        currentAction.printTextObj(eventText, foundAction.match(playerText));
      } else {
        currentAction = defaultAction;
        // Do the aciton
        text.text = getText();
        currentAction.update(dt);
        currentAction.printTextObj(eventText);
      }

      // Reset focus so the user can type
      input.setText(">");
      input.startFocus();

      const conditionals = actions.filter(function(e){
        return e.cond != undefined;
      });
      for(let i=0; i < conditionals.length; i++) {
        let condAction = conditionals[i];
        if(eval(condAction.cond) == true) {
          console.log("MET CONDITION FOR: " + condAction.title);
          // Remove conditional action and add real aciton
          removeCard(condAction.title);
          addCard(condAction.title, condAction.regex)
        }
      }
    }
  }

  function render () {
    game.debug.text(game.time.fps || '--', 2, 14, "#00ff00");
  }
};
</script></body>
</html>
